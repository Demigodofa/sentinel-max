Sentinel MAX — startup and external SSD guide (updated 2024-05-19)
=================================================================

Goal
----
Run Sentinel MAX from an external SSD with sandboxed storage, quick health checks, and upgrade hygiene tips.

1) Put the repo on the external SSD
-----------------------------------
- Mount the drive (examples)
  - Windows: drive letter such as `E:`.
  - macOS/Linux: mount point such as `/Volumes/External` or `/mnt/external`.
- Clone or copy the repo onto the drive
  - Fresh clone: `git clone https://<your-repo-url>.git "<external-path>/sentinel-max"`
  - Copy an existing working tree: `rsync -av --exclude '.venv' /path/to/sentinel-max/ <external-path>/sentinel-max/`
- From now on, run commands from the repo root on that drive.

2) Create an isolated Python environment
----------------------------------------
- Python 3.10+ recommended.
- Create + activate a virtualenv on the SSD so dependencies live with the code:
  - Windows (PowerShell):
    - `python -m venv .venv`
    - `./.venv/Scripts/Activate.ps1`
  - macOS/Linux:
    - `python -m venv .venv`
    - `source .venv/bin/activate`
- Install deps: `pip install -r sentinel/requirements.txt`

3) Keep data on the SSD (storage sandbox)
-----------------------------------------
- Set where Sentinel stores memory and project artifacts (defaults stay repo-local if unset):
  - `SENTINEL_STORAGE_DIR="<external-path>/sentinel-data/memory"`
  - `SENTINEL_PROJECT_STORAGE="<external-path>/sentinel-data/projects"`
- Ensure the folders exist or let the app create them; they must be writable by your user.
- These paths isolate serialized state from the codebase while the built-in execution sandbox restricts Python builtins.

4) Launch commands
------------------
- CLI:   `python -m sentinel.main --mode cli`
- GUI:   `python -m sentinel.main --mode gui`
- API:   `python -m sentinel.main --mode server`
- Helpful slash commands (CLI): `/tools` to list tools, `/tool <name> <json>` to run one, `/auto on` to enable confirmation-free autonomy.

5) Optional one-click Windows launcher (.bat)
---------------------------------------------
Save the following as `start_sentinel_gui.bat` next to the repo and double-click it after editing the paths:
```
@echo off
set SENTINEL_STORAGE_DIR=E:\sentinel-data\memory
set SENTINEL_PROJECT_STORAGE=E:\sentinel-data\projects
call .\.venv\Scripts\activate.bat
python -m sentinel.main --mode gui
```

6) Quick health + smoke checks
------------------------------
- Autonomy loop smoke test (fast):
  - `python -m pytest sentinel/tests/test_autonomy_loop_subsystem.py`
- Memory and ranking pipeline sanity:
  - `python -m pytest sentinel/tests/test_memory_intelligence_subsystem.py`
- Policy + reflection safety sanity:
  - `python -m pytest sentinel/tests/test_policy_engine_subsystem.py sentinel/tests/test_reflection_engine_subsystem.py`
- Long-horizon storage health readout (prints storage readability/writability and project counts):
  - `python - <<"PY"
from sentinel.project.long_horizon_engine import LongHorizonProjectEngine
print(LongHorizonProjectEngine().health_report())
PY`
- Full suite (slower): `python -m pytest sentinel/tests`

7) Hallucination/loop prevention and upgrade hygiene
----------------------------------------------------
- Guardrails always on: PolicyEngine (permissions/metadata/parallelism enforcement), Sandbox (restricted builtins), PatchAuditor + SelfModificationEngine (reject risky edits), approval gating in ExecutionController, and ReflectionEngine for self-critiques.
- Keep upgrades tidy:
  - Work on feature branches; run the smoke checks above before merging.
  - Review and apply agent-generated patches manually after PatchAuditor approval; HotReloader can refresh modules without restarts.
  - Periodically prune old project artifacts under your `SENTINEL_PROJECT_STORAGE` path if no longer needed.

8) Will it still run from the SSD?
----------------------------------
Yes—as long as Python, git, your virtualenv, and the storage env vars point to readable/writable folders on that drive. All entrypoints (`cli`, `gui`, `server`) share the same controller wiring, so runs stay portable across machines.
